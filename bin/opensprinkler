#!/usr/bin/env ruby
# frozen_string_literal: true

require 'bundler/setup'
require 'optparse'
require 'yaml'
require 'fileutils'

$LOAD_PATH.unshift File.expand_path('../lib', __dir__)
require 'opensprinkler'

# Default configuration
config = {
  port: 8080,
  data_dir: '/var/lib/opensprinkler',
  config_file: nil,
  hardware: :auto,
  foreground: false
}

# Parse command line options
OptionParser.new do |opts|
  opts.banner = 'Usage: opensprinkler [options]'

  opts.on('-p', '--port PORT', Integer, 'HTTP port (default: 8080)') do |p|
    config[:port] = p
  end

  opts.on('-d', '--data-dir DIR', 'Data directory (default: /var/lib/opensprinkler)') do |d|
    config[:data_dir] = d
  end

  opts.on('-c', '--config FILE', 'Configuration file') do |c|
    config[:config_file] = c
  end

  opts.on('-H', '--hardware TYPE', [:auto, :ospi, :demo, :mock],
          'Hardware type (auto, ospi, demo, mock)') do |h|
    config[:hardware] = h
  end

  opts.on('-f', '--foreground', 'Run in foreground (don\'t daemonize)') do
    config[:foreground] = true
  end

  opts.on('-v', '--version', 'Show version') do
    puts "OpenSprinkler Ruby v#{OpenSprinkler::VERSION}"
    puts "Firmware compatible: #{OpenSprinkler::Constants::FW_VERSION}.#{OpenSprinkler::Constants::FW_MINOR}"
    exit
  end

  opts.on('-h', '--help', 'Show this help') do
    puts opts
    exit
  end
end.parse!

# Load configuration file if specified
if config[:config_file] && File.exist?(config[:config_file])
  file_config = YAML.load_file(config[:config_file], permitted_classes: [Symbol])
  if file_config
    file_config.each do |key, value|
      config[key.to_sym] = value
    end
  end
end

# Ensure data directory exists
FileUtils.mkdir_p(config[:data_dir])
FileUtils.mkdir_p(File.join(config[:data_dir], 'logs'))

# Create options file path
options_file = File.join(config[:data_dir], 'options.yml')

# Load or create options
int_options = OpenSprinkler::IntegerOptions.new(file_path: options_file)
str_options = OpenSprinkler::StringOptions.new(file_path: options_file)

if File.exist?(options_file)
  int_options.load
  str_options.load
end

# Create combined options object
OptionsWrapper = Struct.new(:int, :string) do
  def save
    int.save
    string.save
  end
end
options = OptionsWrapper.new(int_options, str_options)

# Create GPIO based on hardware type
gpio = OpenSprinkler.create_gpio(config[:hardware])

# Create controller
controller = OpenSprinkler::Controller.new(
  options: options,
  gpio: gpio,
  data_dir: config[:data_dir],
  influxdb_config: File.join(config[:data_dir], 'influxdb.yml')
)

# Configure web app
OpenSprinkler::Web::App.controller = controller
OpenSprinkler::Web::App.options = options

puts "OpenSprinkler Ruby v#{OpenSprinkler::VERSION}"
puts "Firmware compatible: #{OpenSprinkler::Constants::FW_VERSION}.#{OpenSprinkler::Constants::FW_MINOR}"
puts
puts "Starting on port #{config[:port]}..."
puts "Data directory: #{config[:data_dir]}"
puts "Hardware: #{config[:hardware]}"
puts 'Press Ctrl+C to stop'
puts

# Handle shutdown gracefully
shutdown = false
trap('INT') do
  puts "\nShutting down..."
  shutdown = true
end
trap('TERM') { shutdown = true }

# Start web server
require 'puma'
require 'puma/configuration'
require 'puma/launcher'

puma_config = Puma::Configuration.new do |c|
  c.bind "tcp://0.0.0.0:#{config[:port]}"
  c.app OpenSprinkler::Web::App
  c.workers 0
  c.threads 1, 4
  c.quiet
end

launcher = Puma::Launcher.new(puma_config)
web_thread = Thread.new { launcher.run }

# Run main control loop
begin
  until shutdown
    controller.tick
    sleep 0.1
  end
rescue StandardError => e
  puts "Error: #{e.message}"
  puts e.backtrace.first(5).join("\n")
ensure
  controller.stop
  launcher.stop
  web_thread.join(5)
  puts 'Goodbye!'
end
